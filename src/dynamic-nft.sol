// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol";
import "lib/openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "lib/openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "lib/openzeppelin-contracts/contracts/access/Ownable.sol";

contract dynNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _nextTokenId;

    // Metadata information for each stage of the NFT on IPFS.
    string[] IpfsUri = [
        "https://ipfs.io/ipfs/QmWntXFtDqxPUuMmBbxcRvypZEkWc4WKSRzwx1c6aBjqXu?filename=robotRest.json",
        "https://ipfs.io/ipfs/QmfPKm1AYNqncqP7PmW3y2vrgp7NTqhmcSGwxJx9G5dssF?filename=robotStage1.json",
        "https://ipfs.io/ipfs/QmXWtgRuYJN4uLzw2aiA6twuq5iCE9gKTdR9yPZhjGrYu6?filename=robotStage2.json",
        "https://ipfs.io/ipfs/QmUBKkMtaArdJSgsc246uZJuszk57EJCZLomJGGTSJWDQc?filename=robotStage3.json",
        "https://ipfs.io/ipfs/QmSnZsz8BMbnXwavL5PDWgFyxDAoNbwxtuvbxxhtumaXFC?filename=robotStage4.json"
    ];

    uint256 lastTimeStamp;
    uint256 interval;

    constructor(
        uint256 _interval,
        address initialOwner
    ) ERC721("dNFTs", "dNFT") Ownable(initialOwner) {
        interval = _interval;
        lastTimeStamp = block.timestamp;
        _nextTokenId = 1;
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
        return (upkeepNeeded, bytes(""));
    }

    function performUpkeep(bytes calldata /* performData */) external {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            setRobotLvl(0);
        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

    function safeMint(address to) public onlyOwner {
        uint256 tokenId = _nextTokenId;
        _nextTokenId++;
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, IpfsUri[0]);
    }

    uint256 private mockFundSize = 0.1 ether;

    function setMockFundSize(uint256 _size) public onlyOwner {
        mockFundSize = _size;
    }

    function checkFundSize(address) public view returns (uint256) {
        // check for the funds allocated to the yield pool
        return mockFundSize;
    }

    function setRobotLvl(uint256 _tokenId) public {
        // Check the size of the funds for the NFT
        uint256 fundSize = checkFundSize(msg.sender);

        // Determine the new level based on fund size
        uint256 newLevel;
        if (fundSize <= 0.1 ether) {
            newLevel = 0;
        } else if (fundSize <= 0.5 ether) {
            newLevel = 1;
        } else if (fundSize <= 2.5 ether) {
            newLevel = 2;
        } else if (fundSize <= 12 ether) {
            newLevel = 3;
        } else {
            newLevel = 4;
        }

        // Update the URI if the new level is different from the current level
        if (checkRobotlvl(_tokenId) != newLevel) {
            string memory newUri = IpfsUri[newLevel];
            _setTokenURI(_tokenId, newUri);
        }
    }

    // determine the level of the robot
    function checkRobotlvl(
        uint256 _tokenId
    ) public view returns (uint256 _lvl) {
        string memory _uri = tokenURI(_tokenId);
        // rest
        if (compareStrings(_uri, IpfsUri[0])) {
            return 0;
        }
        // lvl 1
        if (compareStrings(_uri, IpfsUri[1])) {
            return 1;
        }
        // lvl 2
        if (compareStrings(_uri, IpfsUri[2])) {
            return 2;
        }
        // lvl 3
        if (compareStrings(_uri, IpfsUri[3])) {
            return 3;
        }
        // lvl 4
        if (compareStrings(_uri, IpfsUri[4])) {
            return 4;
        }
    }

    /*
     ********************
     * HELPER FUNCTIONS *
     ********************
     */
    // helper function to compare strings
    function compareStrings(
        string memory a,
        string memory b
    ) public pure returns (bool) {
        return (keccak256(abi.encodePacked((a))) ==
            keccak256(abi.encodePacked((b))));
    }

    // The following functions are overrides required by Solidity.

    function tokenURI(
        uint256 tokenId
    ) public view override(ERC721, ERC721URIStorage) returns (string memory) {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(
        bytes4 interfaceId
    ) public view override(ERC721, ERC721URIStorage) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}
